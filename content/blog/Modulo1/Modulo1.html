---
title: "Módulo 1"
author: "Wesley de Oliveira Neves LACMAR - UFPE"
date: "2022-01-13"
categories: ["R"]
tags: ["RStudio", "ggplot2", "function()", "Estrutura de Controle"]
output:
  html_document:
    theme: paper
    toc: true
    toc_float: 
      collapsed: false
      smooth_scroll: true
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>
<script src="/rmarkdown-libs/htmlwidgets/htmlwidgets.js"></script>
<link href="/rmarkdown-libs/datatables-css/datatables-crosstalk.css" rel="stylesheet" />
<script src="/rmarkdown-libs/datatables-binding/datatables.js"></script>
<script src="/rmarkdown-libs/jquery/jquery-3.6.0.min.js"></script>
<link href="/rmarkdown-libs/dt-core/css/jquery.dataTables.min.css" rel="stylesheet" />
<link href="/rmarkdown-libs/dt-core/css/jquery.dataTables.extra.css" rel="stylesheet" />
<script src="/rmarkdown-libs/dt-core/js/jquery.dataTables.min.js"></script>
<link href="/rmarkdown-libs/crosstalk/css/crosstalk.min.css" rel="stylesheet" />
<script src="/rmarkdown-libs/crosstalk/js/crosstalk.min.js"></script>


<script type="text/javascript">
$('.title').css('color', 'green')
</script>
<div id="módulo-1-conhecendo-o-ambiente-r" class="section level1">
<h1>Módulo 1 – Conhecendo o Ambiente R</h1>
</div>
<div id="linguagem-de-programação" class="section level1">
<h1>Linguagem de Programação</h1>
<p>Linguagem é uma estrutura sistemática que tem por objetivo a transmissão de ideias e sentimentos (comunicação), ela pode ocorrer através da fala (a língua é um tipo de linguagem que podemos classificar como verbal), escrita (sinais ou símbolos) ou outros signos convencionais. Dessa maneira, uma linguagem de programação é um conjunto de símbolos, sintáticas, regras semânticas destinadas ao controle de uma máquina, por isso ela é uma forma de comunicação entre o ser humano e o computador.</p>
<p>A comunicação entre Homem e Máquina é mediado pelo uso da linguagem de programação, esta por sua vez pode ser classificada como linguagem de alto nível e linguagem de baixo nível, esta classificação está baseada no nível de abstração de cada linguagem de programação.</p>
<div id="linguagem-de-alto-nível" class="section level2">
<h2>Linguagem de Alto Nível</h2>
<p>São linguagens cuja sintaxe são voltadas para o entendimento humano, logo, tais linguagens são mais intuitivas/amigáveis. Para que exista um canal de comunicação entre o emissor (homem) e o receptor (máquina) é necessário que o código seja abstraído e sintetizado de modo que ambos entendam, já que o computador só compreende a linguagem binária. Tomamos como exemplo o Código “PRINT”, o emissor que no caso somos nós, estabelecemos esse comando que será abstraído/ convertido em zeros e uns através dos compiladores para a máquina e ela por sua vez retornará funções que mostrem o conteúdo capturado na tela do computador. São exemplos desse tipo de linguagem o JavaScript, Python, C#, PHP etc.</p>
<p>É intuitivo pensar que os códigos escritos precisam ser compilados ou interpretados para que a máquina entenda o que queremos transmitir. Quando um código é compilado, é gerado outro arquivo que contém todo o código traduzido para algo mais próximo da linguagem da máquina (no caso é um programa em Assembly). Já quando o código é interpretado, cada linha de comando é “traduzida” no momento da execução e é aqui que o Programa R se encaixa. É justamente isso que eleva o tempo de processamento.<br />
</p>
</div>
<div id="linguagem-de-baixo-nível" class="section level2">
<h2>Linguagem de Baixo Nível</h2>
<p>São linguagens voltadas para o entendimento da máquina, logo, tais linguagens possuem uma sintaxe mais complexa e não contam com comandos muito intuitivos. Como mencionado anteriormente, a linguagem da máquina é constituída por sequências de 0 e 1, então a linguagem de baixo nível tem instruções mais diretas para o processador do computador, logo, tais instruções são mais próximas da linguagem da máquina. Um exemplo de tal linguagem é o Assembly.</p>
<p>A linguagem de baixo nível é “traduzida” pelo que chamamos de montador (assembler), que é o responsável por converter o programa Assembly em um conjunto de instruções na linguagem de máquina. Com isso, podemos perceber que o Assembly também atua como uma espécie de interface entre a linguagem de alto nível e a linguagem da máquina.</p>
</div>
<div id="linguagem-de-alto-nível-vs-baixo-nível" class="section level2">
<h2>Linguagem de Alto Nível vs Baixo Nível</h2>
<p>Um simples exemplo é se o emissor deseja que a máquina mostre na tela o código Oi Wesley!.</p>
<p>Em Python (Alto Nível) o Emissor escreveria o seguinte comando: print(” Oi Wesley!“)</p>
<pre class="python"><code>x = &#39;Oi Wesley!&#39;
print(x.split(&#39; &#39;))</code></pre>
<pre><code>## [&#39;Oi&#39;, &#39;Wesley!&#39;]</code></pre>
<p>Em Assembly tal comando seria transcrito da seguinte forma:</p>
<p>lea si, string<br />
call printf<br />
hlt<br />
string db “Oi Wesley!”, 0<br />
printf PROC<br />
mov AL, SI<br />
cmp AL, 0<br />
je pfend<br />
mov AH, 0Eh<br />
int 10h<br />
inc SI<br />
jmp printf<br />
pfend:<br />
ret<br />
printf ENDP</p>
</div>
<div id="vantagens-e-desvantagens-de-cada-uma" class="section level2">
<h2>Vantagens e Desvantagens de cada uma</h2>
<p><strong>Alto Nível:</strong> As principais vantagens são o fácil aprendizado e o baixo custo operacional. As desvantagens reside na exigência de um tempo de processamento maior para executar determinados comandos, por isso que o desempenho de um programa pode ser prejudicado, outra desvantagem é que essa linguagem ocupam mais memórias se comparadas as de baixo nível.</p>
<p><strong>Baixo Nível:</strong> A principal vantagem está no tempo de processamento muito mais rápido do que numa linguagem de alto nível. A desvantagem está na dificuldade de abstração de conceitos nessa linguagem, outra desvantagem é que esses códigos são dedicados a tipos de processadores, logo sua compatibilidade é extremamente limitada.</p>
<p><strong>Resumindo:</strong> Uma linguagem busca facilitar o entendimento humano, enquanto outra se aproxima mais da linguagem da máquina</p>
</div>
</div>
<div id="o-que-é-o-programa-r" class="section level1">
<h1>O que é o programa R?</h1>
<p>Segundo o <a href="https://www.r-project.org/about.html">site</a> oficial do programa o R é uma linguagem e ambiente para computação com foco em estatística e gráficos, é importante perceber que esse ambiente de programação nada mais é que um projeto GNU semelhante a linguagem e ambiente S desenvolvido pela <em>Bell Laboratories</em> por John Chambers e colegas. Por ser basicamente um projeto GNU, o R é um software livre que pode ser estendido através da utilização de pacotes por meio da família CRAN de sites da internet. O termo ambiente pretende caracterizar o R como um sistema totalmente planejado e coerente e ai está a principal diferença entre esse ambiente com os sofwares de análise de dados, o R permite ao pesquisador certa liberdade na hora da análise de dados, já que tal ambiente de programação acompanha o progresso científico, ou seja: novas abordagens metodológicas são desenvolvidas e disponibilizadas nessa plataforma através da criação de pacotes estatísticos, que são disponibilizados para a comunidade científicas através da página oficial CRAN ou pelo github.</p>
<p>O programa foi desenvolvido por George Ross Ihaka e Robert Clifford Gentleman em 1991, nesta ocasião, os professores (Ihaka e Gentleman) que trabalhavam na Universidade de Auckland (Nova Zelândia) desenvolveram uma alternativa à linguagem S, na qual foi oficialmente divulgado em 1995. Em 1997, um grupo central responsável pelas atualizações e estabilizações do programa foi criado e chamado de R Development Core Team, no mesmo ano surgiu o CRAN (Comprehensive R Archive Network) que consiste num conjunto de sites (espelhos) que transportam material idêntico com as contribuições do R de uma forma geral.</p>
<p>A linguagem R é uma linguagem <strong>interpretada</strong>, isto é, o código fonte nessa linguagem é executado por um programa de computador (interpretador) na qual interpreta linha por linha (e aqui está a diferença entre uma linguagem compilada e uma interpretada, na linguagem compilada o compilador converte todo o código de uma vez para a linguagem binária, por causa disso o processo compilado é muito mais rápido que o traduzido, na qual o processo é repetitivo, pois o interpretador processa o código linha por linha) que em seguida é processado pelo sistema operacional ou processador.</p>
</div>
<div id="o-que-é-o-rstudio" class="section level1">
<h1>O que é o RSTudio?</h1>
<p>Basicamente o RStudio (Figura 1) é uma interface gráfica criado por Joseph J. Allaire. Essa interface deixou o R mais popular, já que o RStudio facilita a utilização de vários recursos por meio de botões e uma interface parecida com os programas usuais utilizados por vários sistemas operacionais.</p>
<p>Digamos que o RStudio é mais amigável com o estudante que está aprendendo essa nova linguagem. Uma das vantagens dessa interface é a disposição de quadrantes que organizam as atividades dentro dessa plataforma. Podemos configurar a aparência e a ordem dos quadrantes no RStudio em: <em>Tools &gt; Global Options &gt; Appearance e em Pane Layout</em>.</p>
</div>
<div id="instalando-o-r-e-o-rstudio" class="section level1">
<h1>Instalando o R e o RStudio:</h1>
<p>Como mencionamos anteriormente, uma das vantagens do “programa R” é sua compatibilidade com vários sistemas Operacionais, portanto, vamos mostrar como podemos instalar esse sistema tanto no Windows como no Linux Mint (Uma das distros mais utilizadas do Linux e foi baseada no Ubuntu, portanto essas duas distros possuem ampla compatibilidade entre si).</p>
<div id="instalando-o-r-e-rstudio-no-windows" class="section level2">
<h2>Instalando o R e RStudio no Windows</h2>
<p>Podemos instalar o R nesse <a href="https://cran.r-project.org/bin/windows/base/">link</a> e o RStudio <a href="https://rstudio.com/products/rstudio/download/#download">nesse</a> respectivamente</p>
</div>
<div id="instalando-o-r-e-o-rstudio-no-linux-mint" class="section level2">
<h2>Instalando o R e o RStudio no Linux Mint</h2>
<p>Essa etapa é um pouco mais complicada, no primeiro passo iremos acessar o site oficial do <a href="https://cran.r-project.org/">R</a> em seguida escolhemos a opção <em>“Download R for Linux”</em>, depois selecionamos a opção <em>“ubuntu/”</em> e copiamos a chave do repositório para isso clicamos na opção “full README”, logo iremos copiar o apt-key, no nosso caso copiaremos a chave <strong>“E298A3A825C0D65DFD57CBB651716619E084DAB9”</strong>, com a chave copiada é só acessar no meno iniciar o aplicativo <em>“Fontes de Aplicativos”</em>, em seguida basta clicar na <strong>Chaves de Autenticação</strong> e apertar em baixar, dai é só colar a chave copiada e apertar em OK, após isso aceite a atualização do repositório. Precisamos adicionar o repositório Para isso iremos acessar novamente a página do R e vamos copiar o comando<br />
“deb <a href="https://cloud.r-project.org/bin/linux/ubuntu" class="uri">https://cloud.r-project.org/bin/linux/ubuntu</a> focal-cran40/”, em seguida Adicionaremos esse repositório no aplicativo <strong>Fontes de Aplicativos</strong> e em Adicionar apertaremos em OK, logo adicionaremos o seguinte comando: <em>“sudo apt-get install r-base r-base-dev”</em> no terminal (Ctrl + Alt + T) e confirmamos a instalação digitando S e apertando Enter.</p>
<p>Para abrir o R no terminal é só digitar o R maiúsculo e apertar Enter. ]</p>
<p>Para instalar o RStudio é só acessar o link do <a href="https://rstudio.com/">RStudio</a> ir na opção downloads e escolher a versão Ubuntu18/Debian 10, após baixado é só instalar normalmente como faria no Windows apertando o botão Instalar Pacotes.</p>
<p><img src="/rmarkdown-libs/RStudio.png" title="Interface RStudio" /></p>
</div>
</div>
<div id="entendendo-o-funcionamento-do-r" class="section level1">
<h1>Entendendo o Funcionamento do R:</h1>
<p>Segundo Chambers em seu livro <em>“Extending R”</em> o programa R tem uma estrutura interna uniforme para representar todos os objetos, resumidamente essa estrutura é composta por chamadas de funções que possuem objetos como argumentos e como valor.</p>
<p>Podemos sumarizar esse conceito em três princípios, sendo eles:</p>
<ul>
<li><p><strong>Princípio do Objeto:</strong> Na qual afirma que tudo que existe no R é um OBJETO</p></li>
<li><p><strong>Princípio da Função:</strong> Tudo que acontece no R é uma chamada de FUNÇÃO</p></li>
<li><p><strong>Princípio da Interface:</strong> Interfaces para outros programas são parte do R.</p></li>
</ul>
<p>Podemos resumir o funcionamento do programa na seguinte situação: Toda ação que acontece nesse programa é realizado através de uma <strong>chama de função</strong> o resultado dessa chama de função é <em>armazenada</em> na forma de um <strong>objeto</strong> que por fim é associado a um nome.</p>
<p><img src="/rmarkdown-libs/Fun%C3%A7%C3%B5es-01.png" /></p>
</div>
<div id="iniciando-o-rrstudio" class="section level1">
<h1>Iniciando o R/RStudio:</h1>
<p>Nas linhas de comando do R, mais especificamente no console do RStudio haverá um sinal de &gt;, que indica o prompt, na qual representa que o programa está esperando um comando para realizar uma tarefa. É após esse sinal que iremos escrever nossas linhas de comando. Podemos alterar esse símbolo, escrevendo o seguinte comando</p>
<pre class="r"><code>options(prompt = &quot;W&gt;&quot;)
#Toda vez que o console iniciar, começará por &#39;W&gt;&#39;</code></pre>
<p>É importante estar atento quanto aos nomes dos nossos objetos, já que o programa diferencia letras maiúsculas e minúsculas, logo, não podemos chamar a função <code>library(vegan)</code> escrevendo <code>Library(Vegan)</code>.</p>
<div id="regras-sintáticas-do-programa" class="section level2">
<h2>Regras sintáticas do Programa</h2>
<p>Ao nomear um Objeto, devemos optar pela utilização de letras ou dígitos (preferencialmente); Não podemos iniciar o nome com underline ( _ ); Também não podemos utilizar qualquer uma das palavras reservadas pela linguagem como os operadores lógicos TRUE, FALSE, os operadores de controle IF, FOR, ELSE, WHILE. Se estiver em dúvida utilize a função ?<code>Reserved()</code>.</p>
<p>Devemos utilizar o ponto para representar os números decimais, já que os símbolos , . \ / ; representam funções específicas dentro da linguagem. Como bem sabemos que o R é uma linguagem interpretada, devemos apertar o enter em cada linha de comando digitada para que o console execute tais comandos, ou podemos simplesmente adicionar ; em cada sentença para que o R rode automaticamente todo o código escrito e separado por ponto e vírgula ( ; ), caso o comando digitado esteja incompleto, o programa substituirá o símbolo ( &gt; ) do prompt por um sinal aditivo ( + ). Aqui está uma vantagem do RStudio, se pretendermos escrever o comando para abrir um determinado objeto do tipo função, na qual apresentam argumentos necessários para utilizar de forma correta tais funções, pois esses argumentos apresentam requisitos e elementos necessário para a plena execução dessas funções. Para exemplificar essa vantagem vou utilizar a uma função para abrir pacotes disponíveis na biblioteca do nosso disco rígido, por exemplo, basta escrever <code>librar</code> <em>(de forma incompleta mesmo e o programa vai sugerir imediatamente o complemento dessa função, que no caso é <code>library()</code>, além disso o programa informará automaticamente uma descrição bem resumida da função escrita e dos argumentos que compõe tal função, e se apertarmos F1 automaticamente o programa abrirá a página de ajuda da função/pacote no quadrante help)</em>.</p>
<p>Para encerrar o R/RStudio é só fechar o programa ou escrever <code>q()</code></p>
<p>Esta função geralmente é seguida por uma pergunta <em>save workspace image? y/n/c</em>. Se a resposta dada for y (sim), o programa salvará os conjuntos de dados armazenados na memória, bem como o histórico de comandos. É sempre interessante escrever um registro das análises feitas gravando os comandos em um arquivo de texto chamado arquivo de script, no RStudio basta apertar Ctrl + Enter para que a linha de comando escrita no Script rode no Console.</p>
</div>
<div id="comandos-de-ajuda-no-rstudio" class="section level2">
<h2>Comandos de Ajuda no RStudio</h2>
<p>Podemos abrir facilmente a página de ajuda de um determinado pacote ou função, por exemplo, em ambos os programas (R/RStudio) podemos escrever o comando <code>help(lm)</code> para que a página de help abra em um dos quadrantes da plataforma, do mesmo modo podemos escrever a expressão <code>?lm</code>, para acessar essa mesma página de ajuda.</p>
</div>
<div id="diretório-de-trabalho" class="section level2">
<h2>Diretório de Trabalho</h2>
<p>Basicamente um dos principais erros que acontece em uma rotina de programação R é acessar algum arquivo que não está no diretório de trabalho ou até mesmo salvar em um diretório sem ao menos prestar atenção onde o programa está salvando/acessando os arquivos. Esse lugar é conhecido como diretório de trabalho e o R estabelece uma conexão com esse lugar toda vez que o programa é iniciado. Para verificar seu diretório de trabalho, utilize o comando:</p>
<pre class="r"><code>getwd()</code></pre>
<pre><code>## [1] &quot;/home/weneves/Documentos/site/wenevesR/content/blog/Modulo1&quot;</code></pre>
<p>Para alterar o diretório de trabalho existe a função <code>setwd()</code><br />
No RStudio basta acessarmos <em>Tools/Global Options/General/Default Working Directory (when not in a project)</em>:</p>
<p><code>setwd("/home/weneves/Documentos/Trabalhos R")</code></p>
<p><strong>OBS:</strong> O programa só aceita o formato padrão da Barra Oblíqua / e não a Barra Invertida \ Se você optar em copiar o endereço de um arquivo que não está no diretório de trabalho, basta ir em Propriedades do arquivo e copiar o endereço. O endereço por padrão está escrito com as barras invertidas, então ou você duplica essas barras invertidas ( \\ ) ou inverte para a Barra Normal ( / ). Para salvar o workspace utilizaremos o comando ’save.image() ou Ctrl + Alt + S (RStudio)</p>
<p>O R gravará o workspace no arquivo .RDATA. O .RData salvará todos os objetos criados que estão atualmente disponíveis e o .Rhistory salvará todas as linhas de comandos inseridas no console. Ao iniciar o R no mesmo diretório onde esses arquivos foram salvos, é carregado toda a sua área de trabalho anteriormente, bem como o histórico das linhas de comando utilizadas.</p>
</div>
</div>
<div id="comandos-elementares" class="section level1">
<h1>Comandos Elementares:</h1>
<p>Toda ação que pode ser executada no R pode ser dividida em duas (Expressão e Atribuição), se quiséssemos utilizar o R como calculadora, podemos simplesmente executar o comando:</p>
<pre class="r"><code>1000 + 1014</code></pre>
<pre><code>## [1] 2014</code></pre>
<p>Isto acontece por causa do segundo princípio <em>Tudo que acontece no R é uma chama de função</em> o símbolo de adição no R é simplesmente uma função interna primitiva que foi implementada em outra linguagem. É importante lembrar que toda expressão utilizada no programa fica temporalmente armazenada na memória ativa do computador e uma vez que o resultado é impresso no console, o valor é perdido. Podemos contornar esse problema utilizando o segundo tipo de comando elementar que é a Atribuição (na qual podemos utilizar a junção dos símbolos &lt;- ou =, sendo esse segundo não recomendado, assunto que falaremos posteriormente) não importa a ordem de associação, por exemplo:</p>
<pre class="r"><code>x &lt;- 25; x</code></pre>
<pre><code>## [1] 25</code></pre>
<pre class="r"><code>25 -&gt; x; x</code></pre>
<pre><code>## [1] 25</code></pre>
<p>Também podemos utilizar o comando <code>assign()</code>:</p>
<pre class="r"><code>assign(&quot;name&quot;, &quot;wesley&quot;); name</code></pre>
<pre><code>## [1] &quot;wesley&quot;</code></pre>
<p>Quando utilizamos o comando de atribuição no console, o R armazena o nome associado ao objeto (é importante lembrar que ao utilizarmos essa função, estamos apenas associando um nome a um objeto, que no caso pode ser uma função, um valor, um caractere etc e não estamos de fato, utilizando essa função para criar um objeto) na sua área de trabalho que é comumente chamada de Ambiente Global (o propósito de um ambiente no R é associar um conjunto de nomes a um conjunto de valores)</p>
<p>Podemos criar alguns nomes e associá-los a alguns valores, por exemplo:</p>
<pre class="r"><code>D &lt;- c(&quot;25-07-2014&quot;); x &lt;- 3.14; e &lt;- 2.71; D; x; e</code></pre>
<pre><code>## [1] &quot;25-07-2014&quot;</code></pre>
<pre><code>## [1] 3.14</code></pre>
<pre><code>## [1] 2.71</code></pre>
<p>Podemos verificar todos os nomes armazenadas no ambiente global através da função <code>ls()</code></p>
<pre class="r"><code>ls()</code></pre>
<pre><code>## [1] &quot;D&quot;    &quot;e&quot;    &quot;name&quot; &quot;x&quot;</code></pre>
</div>
<div id="objetos" class="section level1">
<h1>Objetos</h1>
<p>Lembrando do primeiro princípio do R <em>Tudo que existe no R é um Objeto</em>, e o que seria esse tal de objeto?</p>
<p>A ciência da computação define um objeto como um local da memória destinado a um determinado valor, dessa forma, o objeto pode ser uma variável, uma função ou simplesmente uma estrutura de dados. Mas na Programação Orientada a Objetos, a palavra se refere a um Molde/Classe que passa a existir a partir de uma instância da classe, ou seja, a classe define o comportamento do objeto (utilizando para tais, seus atributos que nada mais são que propriedades e suas ações que são seus métodos). Dessa maneira, podemos resumir a definição de objeto como uma entidade no ambiente R que possuí características internas e tas características são extremamente necessárias para que o programa possa interpretar sua estrutura e seu conteúdo, como vimos acima, tais características são chamadas de atributos.</p>
<p>Podemos retornar ao enunciado que comumente proferimos ao utilizar o R <em>“Criei um objeto x que recebe um valor y”</em>. Segundo a lógica de funcionamento do R, tal afirmação é bastante imprecisa e o correto seria afirmar que o objeto y recebe um nome ou mais corretamente “está se ligando” ao nome x, ou seja, o objeto não tem um nome, mas o nome possui um objeto. Para visualizar qual objeto associado a um nome, basta digitarmos no console o nome associado a tal objeto e apertar a tecla ENTER.</p>
<p>Como afirma Paradis em seu livro “R for Beginners” os objetos são caracterizados pelos seus nomes e pelo seu conteúdo, sendo mais específico seu atributo que normalmente irá especificar o tipo de dados representados por um objeto. podemos utilizar o mesmo exemplo que o autor citado acima trás em seu livro: <em>“considere uma variável que assume o valor 1, 2 ou 3: tal variável pode ser uma variável inteira (por exemplo, o número de ovos em um ninho), ou a codificação de uma variável categórica (por exemplo, sexo em algumas populações de crustáceos: machos, fêmeas ou hermafroditas). É claro que a análise estatística desta variável não será a mesma em ambos os casos: com R, os atributos do objeto fornecem as informações necessárias”.</em> Logo, a ação de um objeto depende dos seus respectivos atributos.</p>
<p>No R todos os objetos possuem uma classe e dois atributos intrínsecos. A forma de verificar a classe de um objeto é através da função class(), mas essa função pode apresentar resultados equívocos e por isso podemos utilizar a função sloop::s3_class() do pacote sloop.</p>
<p><strong><em>OBS:</em></strong> também existe um atributo chamado classe (class) e os objetos que possuem tal atriuto são apenas os desenvolvidos na programação orientada a objetos (que é uma programação desenvolvida em um dos principais paradigmas da programação que é baseada no conceito de objetos).</p>
<pre class="r"><code>q &lt;- 10; a &lt;- factor(q); class(q); class(a)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<p>Apesar do objeto a possuir o mesmo “conteúdo” que q, pelo simples fato de atribuímos a classe factor ao objeto a, o valor contido em tal nome deixa de se comportar como numérico e passa a ser considerado como fator, portanto, realizar operações algébricas com o objeto a é impossível.</p>
<p>A função <code>attibutes()</code> verifica se determinado objeto possuí o atributo class. As classes dos objetos podem ser: <em>numeric, logical, character, list, matrix, arraym factor e data.frame.</em> Podemos remover a classe de um objeto com a função <code>unclass()</code>. Vamos observar como um data frame se comporta sem a sua classe:</p>
<pre class="r"><code>neo &lt;- data.frame(a = 1:16, b = LETTERS[1:16]); class(neo)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<p>Agora vamos remover a classe do objeto neo:</p>
<pre class="r"><code>b &lt;- unclass(neo); b; class(b)</code></pre>
<pre><code>## $a
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
## 
## $b
##  [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot;
## 
## attr(,&quot;row.names&quot;)
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<p>Observamos que sem o atributo de classe <em>data.frame</em> o objeto tem a classe list, ou seja, mesmo que os dados possuam uma estrutura de lista ele se comporta como data.frame se possuir o atributo data.frame.</p>
<div id="atributos-intrínsecos" class="section level2">
<h2>Atributos Intrínsecos</h2>
<p>Todos os objetos no R possuem dois atributos intrínsecos sendo eles o <strong>modo</strong> e o <strong>comprimento</strong>.</p>
<ul>
<li><p>O modo é o tipo mais básico dos elementos do objeto e existem cerca de quatro modos principais sendo eles <em>numérico, caractere, complexo e lógico</em> (existem outros modos, mas eles não representam dados, como a função e expressão).</p></li>
<li><p>O comprimento é o número de elementos do objeto. Podemos facilmente consultar essas informações utilizando as funções<code>mode()</code>e <code>lenght()</code>, respectivamente:</p></li>
</ul>
<pre class="r"><code>Alunos_R &lt;- 8; mode(Alunos_R)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>Alunos_R1 &lt;- 8L; mode(Alunos_R1)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p>É importante perceber aqui que embora a quantidade de alunos é igual nesses dois exemplos (Alunos_R == Alunos_R1), a função <code>mode()</code> é baseada em uma das linguagem que o R foi baseado (linguagem S), logo ela não faz distinção entre números inteiros e numéricos, essa implementação foi disponibilizada na linguagem C (já que boa parte da rotina do R está desenvolvida nessa linguagem, um exemplo é o pacote base), podemos verificar essa informação através do comando <code>typeof()</code></p>
<pre class="r"><code>typeof(Alunos_R); typeof(Alunos_R1)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<p>A diferença entre ambas essas duas formas está simplesmente na forma que o R armazena essas informações na memória do computador, podemos realizar alguns testes no R:</p>
<pre class="r"><code>is.numeric( Alunos_R)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>is.numeric( Alunos_R1)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>is.integer(Alunos_R)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>is.integer(Alunos_R1)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Colocar o ‘L’ maiúsculo após um número inteiro força o R a armazenar o valor do objeto como um número inteiro, logo, inteiro seria uma subconjunto de numérico.</p>
<p>O termo double retornado pela função<code>typeof()</code> significa dupla precisão na linguagem de programação, que acaba tenho uma exigência de mais memória do que o objeto de modo integer. Esses termos são utilizados na linguagem C. Já a linguagem S não os diferencia, utilizando tudo como numeric.</p>
<pre class="r"><code>Nomes_alunos_R &lt;- c(&quot;Beethoven&quot;,&quot;Chopin&quot;,&quot;Lizt&quot;,&quot;Mozart&quot;,&quot;Bach&quot;,&quot;Tchaikovsky&quot;,&quot;Debussy&quot;,&quot;Schubert&quot;); mode(Nomes_alunos_R)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>Alunos_Matriculados &lt;- Alunos_R == 8; mode(Alunos_Matriculados)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<pre class="r"><code>x &lt;- 3i; mode(x) #Complex</code></pre>
<pre><code>## [1] &quot;complex&quot;</code></pre>
<p>O comprimento de um objeto é informado pela função <code>length()</code></p>
<pre class="r"><code>length(Nomes_alunos_R)</code></pre>
<pre><code>## [1] 8</code></pre>
</div>
</div>
<div id="tipos-de-objetos" class="section level1">
<h1>Tipos de Objetos:</h1>
<p>Quando nos referimos a tipos de objeto, estamos pensando na forma que os dados estão organizados, um dos tipos mais simples de objetos são os vetores atômicos que armazenam apenas um conjunto de elementos do mesmo modo <em>(numérico, caractere, complexo e lógico)</em> pela natureza desses objetos (armazenam elementos de apenas um modo) os dados se comportariam do mesmo modo mesmo constituídos de elementos diferentes, por exemplo:</p>
<pre class="r"><code>H &lt;- c(&quot;shannon&quot;, 2.75, 1.68, 2.18, 0.78); H</code></pre>
<pre><code>## [1] &quot;shannon&quot; &quot;2.75&quot;    &quot;1.68&quot;    &quot;2.18&quot;    &quot;0.78&quot;</code></pre>
<p>Observamos que todos os elementos dispostos no meu objeto ganharam aspas, se verificarmos o modo desse objeto constataremos que os dados são characteres. Esse fato chamamos de coerção entre vetores. Os vetores lógicos (TRUE e FALSE) serão convertidos em 1 e 0 respectivamente. A função <code>as. &lt;modo</code> força a coerção dos objetos e para saber se um objeto possui determinado modo, utilizamos a função <code>is. &lt;modo</code>.</p>
<p>Os objetos podem ser resumidos em vetores atômicos ou listas, sendo subdivididos em:</p>
<ul>
<li><p>Vetores Atômicos <em>(Lógicos, Numéricos e Caracteres; Matrizes Unidimensionais <strong>Matrix</strong> e Multidimensionais <strong>Arrays</strong>)</em></p></li>
<li><p>Vetores em Listas <em>(Listas e Quadro de Dados <strong>Data.frames</strong>).</em> A diferença entre os Vetores Atômicos e os Vetores em Listas é que o segundo suporta a presença de vários modos no mesmo objeto, enquanto os vetores atômicos não.</p></li>
</ul>
<div id="vetor-numérico" class="section level2">
<h2>Vetor Numérico:</h2>
<pre class="r"><code>dados &lt;- c(1,2,3,4,5,6,7,8,9); dados</code></pre>
<pre><code>## [1] 1 2 3 4 5 6 7 8 9</code></pre>
<pre class="r"><code>X &lt;- seq(1,10,2); X #Cria uma sequência de números de 1 até 10 2 em 2.</code></pre>
<pre><code>## [1] 1 3 5 7 9</code></pre>
<pre class="r"><code>Y &lt;- rep(2:5, 2); Y #Repete a sequência de 2 até 5 duas vezes.</code></pre>
<pre><code>## [1] 2 3 4 5 2 3 4 5</code></pre>
<p>Um conjunto de dados aleatórios pode ser obtido pela função<code>runif(número de dado, min=,max)</code></p>
<pre class="r"><code>teste &lt;- runif(10, min = 30, max = 65); teste</code></pre>
<pre><code>##  [1] 45.25772 53.95934 43.87197 31.95414 42.78474 37.46787 36.32236 41.07935
##  [9] 34.66966 62.98464</code></pre>
<pre class="r"><code>#Rnorm()&#39; gera números aleatórios com distribuição normal:
exemplo_distNorm &lt;- rnorm(100, mean = 50, sd = 5); exemplo_distNorm</code></pre>
<pre><code>##   [1] 50.68622 45.57123 46.90622 52.48020 58.43940 51.23361 52.87842 53.22729
##   [9] 47.86531 45.92494 51.84445 46.63798 53.85867 46.19265 44.36638 45.58660
##  [17] 49.24618 50.81872 52.23082 51.70235 46.41319 50.61738 51.48093 51.96094
##  [25] 51.43718 46.57022 58.72929 50.34592 54.02161 50.48398 47.28029 50.50562
##  [33] 46.26120 51.09577 50.95322 54.95361 38.71668 54.94505 48.19601 46.03606
##  [41] 59.35029 48.50920 56.76520 56.15839 53.40780 45.57495 47.54021 47.94613
##  [49] 48.38822 51.31462 52.00085 40.91765 47.31591 53.45245 50.25270 41.37715
##  [57] 46.25650 52.04812 54.65576 44.36854 49.23893 52.61994 47.18783 50.33935
##  [65] 53.82566 48.13305 47.92522 43.50509 58.90795 45.42540 42.44905 52.51963
##  [73] 51.58637 47.58270 55.75896 51.97143 36.69149 57.92126 50.61811 49.49419
##  [81] 43.05919 58.22610 50.32825 46.30206 52.39902 49.74067 47.59171 43.87419
##  [89] 63.41447 51.90818 47.50638 55.40524 50.80455 45.37237 49.24284 51.70684
##  [97] 55.67175 53.78027 41.29435 45.52571</code></pre>
<p>Como selecionar amostras aleatórias de um conjunto de dados?</p>
<p><code>sample(x, size, replace)</code></p>
<p>x: vetor com o conjunto de amostras, size: número de amostras a serem selecionadas, replace: lógico, TRUE= com reposição, FALSE= sem reposição.</p>
<pre class="r"><code>sample(1:30, 5, replace = FALSE)</code></pre>
<pre><code>## [1]  5  9 17 15 21</code></pre>
</div>
<div id="vetor-de-caracter" class="section level2">
<h2>Vetor de Caracter</h2>
<p>Vetores com nomes ao invés de números.</p>
<p><strong>OBS:</strong> No R sequências de caracteres textuais são sempre delimitados por aspas.</p>
<pre class="r"><code>dados_chopin &lt;- c(Nome = &quot;Frédéric François Chopin&quot;, Nascimento = &quot;22/02/1810&quot;, Profissao = &quot;Compositor e Pianista&quot;); dados_chopin</code></pre>
<pre><code>##                       Nome                 Nascimento 
## &quot;Frédéric François Chopin&quot;               &quot;22/02/1810&quot; 
##                  Profissao 
##    &quot;Compositor e Pianista&quot;</code></pre>
</div>
<div id="vetor-lógico" class="section level2">
<h2>Vetor Lógico</h2>
<p>Quantidades lógicas no R, sendo eles TRUE, FALSE ou NA</p>
<pre class="r"><code>is.factor(&#39;dados_chopin&#39;)</code></pre>
<pre><code>## [1] FALSE</code></pre>
</div>
<div id="fator" class="section level2">
<h2>Fator</h2>
<p>Fator é um vetor usado para criar variável categórica (medida em uma escala nominal) que são bastantes comuns em análises estatísticas.</p>
<pre class="r"><code>alturas &lt;- factor(c(&quot;baixo&quot;,&quot;médio&quot; ,&quot;alto&quot;)); alturas #notem que utilizamos um acento em médio, isto é possível porque esta palavra aqui é tratada como um caracter (por isso as aspas)</code></pre>
<pre><code>## [1] baixo médio alto 
## Levels: alto baixo médio</code></pre>
<pre class="r"><code>is.factor(alturas) # testa a conversão</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="matriz" class="section level2">
<h2>Matriz</h2>
<p>Nada mais é que um conjunto de 2 dimensões de vetores (Linhas e colunas)</p>
<p>Escreva matr no RStudio para verificar o corpo da Matrix.</p>
<p><em>Corpo da Matrix: (data, nrow(n°linhas), ncol(n°colunas), byrow(F or T Organiza a distr. dos n°), dimnames(nomes))</em></p>
<pre class="r"><code>xyz &lt;- matrix(1:100, ncol = 10, byrow = FALSE); xyz # Matriz com byrow = T -&gt; Distribui os números por linhas # Matriz com byrow = F -&gt; Distribui por colunas</code></pre>
<pre><code>##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
##  [1,]    1   11   21   31   41   51   61   71   81    91
##  [2,]    2   12   22   32   42   52   62   72   82    92
##  [3,]    3   13   23   33   43   53   63   73   83    93
##  [4,]    4   14   24   34   44   54   64   74   84    94
##  [5,]    5   15   25   35   45   55   65   75   85    95
##  [6,]    6   16   26   36   46   56   66   76   86    96
##  [7,]    7   17   27   37   47   57   67   77   87    97
##  [8,]    8   18   28   38   48   58   68   78   88    98
##  [9,]    9   19   29   39   49   59   69   79   89    99
## [10,]   10   20   30   40   50   60   70   80   90   100</code></pre>
<pre class="r"><code>colnames(xyz) &lt;- c(&quot;grupo1&quot;,&quot;grupo2&quot;,&quot;grupo3&quot;,&quot;grupo4&quot;,&quot;grupo5&quot;,&quot;grupo6&quot;,&quot;grupo7&quot;,&quot;grupo8&quot;,&quot;grupo9&quot;,&quot;grupo10&quot;); rownames(xyz) &lt;- rownames(xyz, do.NULL = FALSE, prefix = &quot;Obs.&quot;); linhas &lt;- letters[1:10]; rownames(xyz) &lt;- linhas; xyz</code></pre>
<pre><code>##   grupo1 grupo2 grupo3 grupo4 grupo5 grupo6 grupo7 grupo8 grupo9 grupo10
## a      1     11     21     31     41     51     61     71     81      91
## b      2     12     22     32     42     52     62     72     82      92
## c      3     13     23     33     43     53     63     73     83      93
## d      4     14     24     34     44     54     64     74     84      94
## e      5     15     25     35     45     55     65     75     85      95
## f      6     16     26     36     46     56     66     76     86      96
## g      7     17     27     37     47     57     67     77     87      97
## h      8     18     28     38     48     58     68     78     88      98
## i      9     19     29     39     49     59     69     79     89      99
## j     10     20     30     40     50     60     70     80     90     100</code></pre>
<pre class="r"><code>t(xyz)#transpõe a matriz</code></pre>
<pre><code>##          a  b  c  d  e  f  g  h  i   j
## grupo1   1  2  3  4  5  6  7  8  9  10
## grupo2  11 12 13 14 15 16 17 18 19  20
## grupo3  21 22 23 24 25 26 27 28 29  30
## grupo4  31 32 33 34 35 36 37 38 39  40
## grupo5  41 42 43 44 45 46 47 48 49  50
## grupo6  51 52 53 54 55 56 57 58 59  60
## grupo7  61 62 63 64 65 66 67 68 69  70
## grupo8  71 72 73 74 75 76 77 78 79  80
## grupo9  81 82 83 84 85 86 87 88 89  90
## grupo10 91 92 93 94 95 96 97 98 99 100</code></pre>
<pre class="r"><code>class(xyz)</code></pre>
<pre><code>## [1] &quot;matrix&quot; &quot;array&quot;</code></pre>
<pre class="r"><code>xyz[,1] #para acessar a primeira coluna de uma matriz. [linha, coluna]</code></pre>
<pre><code>##  a  b  c  d  e  f  g  h  i  j 
##  1  2  3  4  5  6  7  8  9 10</code></pre>
<p><code>fix(xyz) #edita uma matriz ou data frame IMPORTANTE!!</code></p>
<pre class="r"><code>str(xyz)#avalia a estrutura do objeto</code></pre>
<pre><code>##  int [1:10, 1:10] 1 2 3 4 5 6 7 8 9 10 ...
##  - attr(*, &quot;dimnames&quot;)=List of 2
##   ..$ : chr [1:10] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ...
##   ..$ : chr [1:10] &quot;grupo1&quot; &quot;grupo2&quot; &quot;grupo3&quot; &quot;grupo4&quot; ...</code></pre>
<pre class="r"><code>summary(xyz)</code></pre>
<pre><code>##      grupo1          grupo2          grupo3          grupo4     
##  Min.   : 1.00   Min.   :11.00   Min.   :21.00   Min.   :31.00  
##  1st Qu.: 3.25   1st Qu.:13.25   1st Qu.:23.25   1st Qu.:33.25  
##  Median : 5.50   Median :15.50   Median :25.50   Median :35.50  
##  Mean   : 5.50   Mean   :15.50   Mean   :25.50   Mean   :35.50  
##  3rd Qu.: 7.75   3rd Qu.:17.75   3rd Qu.:27.75   3rd Qu.:37.75  
##  Max.   :10.00   Max.   :20.00   Max.   :30.00   Max.   :40.00  
##      grupo5          grupo6          grupo7          grupo8     
##  Min.   :41.00   Min.   :51.00   Min.   :61.00   Min.   :71.00  
##  1st Qu.:43.25   1st Qu.:53.25   1st Qu.:63.25   1st Qu.:73.25  
##  Median :45.50   Median :55.50   Median :65.50   Median :75.50  
##  Mean   :45.50   Mean   :55.50   Mean   :65.50   Mean   :75.50  
##  3rd Qu.:47.75   3rd Qu.:57.75   3rd Qu.:67.75   3rd Qu.:77.75  
##  Max.   :50.00   Max.   :60.00   Max.   :70.00   Max.   :80.00  
##      grupo9         grupo10      
##  Min.   :81.00   Min.   : 91.00  
##  1st Qu.:83.25   1st Qu.: 93.25  
##  Median :85.50   Median : 95.50  
##  Mean   :85.50   Mean   : 95.50  
##  3rd Qu.:87.75   3rd Qu.: 97.75  
##  Max.   :90.00   Max.   :100.00</code></pre>
</div>
<div id="lista" class="section level2">
<h2>Lista</h2>
<p>Uma lista é um objeto que consiste de um conjunto de dados com modos diferentes ordenados de forma hierárquica. Por exemplo, é possível construir uma lista com uma matriz, um vetor lógico etc.</p>
<pre class="r"><code>loboG &lt;- list(Nome = &quot;Lobo Guará&quot;, Reino = &quot;Animalia&quot;, Filo = &quot;Chordata&quot;, Classe = &quot;Mammalia&quot;, Ordem = &quot;Carnivora&quot;, Família = &quot;Canidae&quot;, Gênero = &quot;Chrysocyon&quot;, Espécie = &quot;C. brachyurus&quot;, NomeB = &quot;Chrysocyon brachyurus&quot;); loboG</code></pre>
<pre><code>## $Nome
## [1] &quot;Lobo Guará&quot;
## 
## $Reino
## [1] &quot;Animalia&quot;
## 
## $Filo
## [1] &quot;Chordata&quot;
## 
## $Classe
## [1] &quot;Mammalia&quot;
## 
## $Ordem
## [1] &quot;Carnivora&quot;
## 
## $Família
## [1] &quot;Canidae&quot;
## 
## $Gênero
## [1] &quot;Chrysocyon&quot;
## 
## $Espécie
## [1] &quot;C. brachyurus&quot;
## 
## $NomeB
## [1] &quot;Chrysocyon brachyurus&quot;</code></pre>
</div>
<div id="data-frame" class="section level2">
<h2>Data Frame</h2>
<p>Parecido com uma matriz, a única diferença é que este tipo de objeto aceita vetores de tipos diferentes, por causa dessa característica o data frame é o tipo de objeto mais utilizado no R</p>
<pre class="r"><code>comunidade &lt;- data.frame(especies = c(&quot;D.nanus&quot;, &quot;S.alter&quot;,&quot;I.guentheri&quot;, &quot;A. callipygius&quot;), habitat = factor(c(&quot;Folhiço&quot;, &quot;Arbóreo&quot;, &quot;Riacho&quot;, &quot;Poça&quot;)), altura = c(1.1, 0.8, 0.9, 1), distancia = c(1, 1.7, 0.6, 0.2)); comunidade</code></pre>
<pre><code>##         especies habitat altura distancia
## 1        D.nanus Folhiço    1.1       1.0
## 2        S.alter Arbóreo    0.8       1.7
## 3    I.guentheri  Riacho    0.9       0.6
## 4 A. callipygius    Poça    1.0       0.2</code></pre>
<pre class="r"><code>knitr::kable(comunidade)</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">especies</th>
<th align="left">habitat</th>
<th align="right">altura</th>
<th align="right">distancia</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">D.nanus</td>
<td align="left">Folhiço</td>
<td align="right">1.1</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">S.alter</td>
<td align="left">Arbóreo</td>
<td align="right">0.8</td>
<td align="right">1.7</td>
</tr>
<tr class="odd">
<td align="left">I.guentheri</td>
<td align="left">Riacho</td>
<td align="right">0.9</td>
<td align="right">0.6</td>
</tr>
<tr class="even">
<td align="left">A. callipygius</td>
<td align="left">Poça</td>
<td align="right">1.0</td>
<td align="right">0.2</td>
</tr>
</tbody>
</table>
<pre class="r"><code>DT::datatable(comunidade)</code></pre>
<div id="htmlwidget-1" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-1">{"x":{"filter":"none","vertical":false,"data":[["1","2","3","4"],["D.nanus","S.alter","I.guentheri","A. callipygius"],["Folhiço","Arbóreo","Riacho","Poça"],[1.1,0.8,0.9,1],[1,1.7,0.6,0.2]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>especies<\/th>\n      <th>habitat<\/th>\n      <th>altura<\/th>\n      <th>distancia<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"columnDefs":[{"className":"dt-right","targets":[3,4]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<pre class="r"><code>class(comunidade)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>str(comunidade)</code></pre>
<pre><code>## &#39;data.frame&#39;:    4 obs. of  4 variables:
##  $ especies : chr  &quot;D.nanus&quot; &quot;S.alter&quot; &quot;I.guentheri&quot; &quot;A. callipygius&quot;
##  $ habitat  : Factor w/ 4 levels &quot;Arbóreo&quot;,&quot;Folhiço&quot;,..: 2 1 4 3
##  $ altura   : num  1.1 0.8 0.9 1
##  $ distancia: num  1 1.7 0.6 0.2</code></pre>
<p><code>fix(comunidade</code></p>
<p><code>edit(comunidade)</code></p>
<p>O símbolo $ é o responsável pela seleção das colunas de um data frame, antes do $ vem o nome do objeto, depois, o nome da coluna.</p>
</div>
<div id="operações-no-r" class="section level2">
<h2>Operações no R</h2>
<table>
<colgroup>
<col width="19%" />
<col width="80%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="center">+</td>
<td align="center">Soma unária, ou binária entre dois vetores</td>
</tr>
<tr class="even">
<td align="center">-</td>
<td align="center">Subtração pode ser unária ou binária</td>
</tr>
<tr class="odd">
<td align="center">*</td>
<td align="center">Multiplicação entre dois vetores</td>
</tr>
<tr class="even">
<td align="center">/</td>
<td align="center">Divisão entre dois vetores</td>
</tr>
<tr class="odd">
<td align="center">^ ou **</td>
<td align="center">Exponenciação binária, isto é 2^5 ou 2 ** 5</td>
</tr>
<tr class="even">
<td align="center">% / %</td>
<td align="center">Divisão inteira</td>
</tr>
<tr class="odd">
<td align="center">%%</td>
<td align="center">Restante da divisão</td>
</tr>
<tr class="even">
<td align="center">sum()</td>
<td align="center">Soma de elementos</td>
</tr>
<tr class="odd">
<td align="center">prod()</td>
<td align="center">Produto dos elementos</td>
</tr>
<tr class="even">
<td align="center">sqrt()</td>
<td align="center">Raiz quadrada</td>
</tr>
<tr class="odd">
<td align="center">log()</td>
<td align="center">Função Logaritmo Neperiano</td>
</tr>
<tr class="even">
<td align="center">log10()</td>
<td align="center">Função Logaritmo na base 10</td>
</tr>
<tr class="odd">
<td align="center">log(x, base = y)</td>
<td align="center">Logaritmo na base y do vetor ou escalar x</td>
</tr>
<tr class="even">
<td align="center">exp()</td>
<td align="center">Função exponencial</td>
</tr>
<tr class="odd">
<td align="center">mean()</td>
<td align="center">Média</td>
</tr>
<tr class="even">
<td align="center">sd()</td>
<td align="center">Descio padrão</td>
</tr>
<tr class="odd">
<td align="center">var()</td>
<td align="center">Variância</td>
</tr>
<tr class="even">
<td align="center">median()</td>
<td align="center">Mediana</td>
</tr>
<tr class="odd">
<td align="center">round()</td>
<td align="center">Arredondamento de vetor numérico. Outros tipos são: trunc(), floor() e ceiling()</td>
</tr>
<tr class="even">
<td align="center">signif(x, digits = n)</td>
<td align="center">Arredondamento de vetor numérico. Outros tipos são: trunc(), floor() e ceiling()</td>
</tr>
<tr class="odd">
<td align="center">ceiling()</td>
<td align="center">Arredonda o valor do vetor para o maior valor</td>
</tr>
<tr class="even">
<td align="center">floor()</td>
<td align="center">Arredonda o valor para o menor valor</td>
</tr>
<tr class="odd">
<td align="center">factorial()</td>
<td align="center">Fatorial</td>
</tr>
<tr class="even">
<td align="center">trunc()</td>
<td align="center">Trunca (corta) as decimais do vetor</td>
</tr>
<tr class="odd">
<td align="center">length()</td>
<td align="center">Retorna o tamanho do vetor</td>
</tr>
<tr class="even">
<td align="center">sort()</td>
<td align="center">Retorna o vetor com os valores em ordem crescente</td>
</tr>
<tr class="odd">
<td align="center">max()</td>
<td align="center">Retorna o valor máximo do vetor</td>
</tr>
<tr class="even">
<td align="center">min()</td>
<td align="center">Retorna o valor mínimo do vetor</td>
</tr>
<tr class="odd">
<td align="center">range()</td>
<td align="center">Retorna a amplitude do vetor</td>
</tr>
<tr class="even">
<td align="center">summary()</td>
<td align="center">Sumário estatístico do vetor</td>
</tr>
<tr class="odd">
<td align="center">aov(y ~ x, data = d)</td>
<td align="center">Análise de variância unidirecional do quadro de dados d. Variável dependente (y) variável independente (x)</td>
</tr>
<tr class="even">
<td align="center">aov(y ~ x*z, data = d)</td>
<td align="center">Análise de variância bidirecional</td>
</tr>
<tr class="odd">
<td align="center">cor(x, y)</td>
<td align="center">Coeficiente de correlação</td>
</tr>
<tr class="even">
<td align="center">cor.teste(x, y)</td>
<td align="center">Retorna o coeficiente de correlação com um teste-t de significância</td>
</tr>
<tr class="odd">
<td align="center">lm(y ~x, data = d)</td>
<td align="center">Análise de regressão linear</td>
</tr>
</tbody>
</table>
</div>
<div id="resumo-de-funções" class="section level2">
<h2>Resumo de Funções</h2>
<table>
<thead>
<tr class="header">
<th align="center">Vetor</th>
<th align="center">Matriz</th>
<th align="center">Array</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">names()</td>
<td align="center">rownames(), colnames()</td>
<td align="center">dimnames()</td>
</tr>
<tr class="even">
<td align="center">length()</td>
<td align="center">nrow(), ncol()</td>
<td align="center">dim()</td>
</tr>
<tr class="odd">
<td align="center">c()</td>
<td align="center">rbind(), cbind()</td>
<td align="center">abind::abind()</td>
</tr>
<tr class="even">
<td align="center">-</td>
<td align="center">t()</td>
<td align="center">aperm()</td>
</tr>
<tr class="odd">
<td align="center">is.null(dim(x))</td>
<td align="center">is.matrix()</td>
<td align="center">is.array</td>
</tr>
</tbody>
</table>
</div>
<div id="operadores-lógicos" class="section level2">
<h2>Operadores Lógicos</h2>
<table>
<colgroup>
<col width="21%" />
<col width="28%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Operadores Lógicos</th>
<th align="center">Sintaxe</th>
<th align="center">Pergunta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">&lt;</td>
<td align="center">a &lt; b</td>
<td align="center">a é menor que b</td>
</tr>
<tr class="even">
<td align="center">&gt;</td>
<td align="center">a &gt; b</td>
<td align="center">a é maior que b</td>
</tr>
<tr class="odd">
<td align="center">==</td>
<td align="center">a == b</td>
<td align="center">a é igual a b</td>
</tr>
<tr class="even">
<td align="center">!=</td>
<td align="center">a != b</td>
<td align="center">a é diferente de b</td>
</tr>
<tr class="odd">
<td align="center">&gt;=</td>
<td align="center">a &gt;= b</td>
<td align="center">a é maior ou igual a b</td>
</tr>
<tr class="even">
<td align="center">&lt;=</td>
<td align="center">a &lt;= b</td>
<td align="center">a é menor ou igual a b</td>
</tr>
<tr class="odd">
<td align="center">%in%</td>
<td align="center">“a” %in% c(“a”, “b”, “c”)</td>
<td align="center">O elemento “a” está no vetor c(“a”, “b”, “c”)?</td>
</tr>
</tbody>
</table>
</div>
<div id="operadores-booleanos" class="section level2">
<h2>Operadores Booleanos</h2>
<table>
<thead>
<tr class="header">
<th align="center">Operadores Booleanos</th>
<th align="center">Sintaxe</th>
<th align="center">Pergunta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">&amp; ou &amp;&amp;</td>
<td align="center">cond1 &amp; cond2</td>
<td align="center">As cond1 e cond2 são verdadeiras?</td>
</tr>
<tr class="even">
<td align="center">| ou ||</td>
<td align="center">cond1| cond2</td>
<td align="center">A cond1 ou cond2 é verdadeira?</td>
</tr>
<tr class="odd">
<td align="center">xor()</td>
<td align="center">xor(cond1, cond2)</td>
<td align="center">Apenas a cond1 ou a cond2 é verdadeira?</td>
</tr>
<tr class="even">
<td align="center">!</td>
<td align="center">!cond1</td>
<td align="center">É falso a cond1?</td>
</tr>
<tr class="odd">
<td align="center">any()</td>
<td align="center">any(cond1, cond2, …)</td>
<td align="center">Algumas das condições são verdadeiras?</td>
</tr>
<tr class="even">
<td align="center">all()</td>
<td align="center">all(cond1, cond2, …)</td>
<td align="center">Todas as condições são verdadeiras?</td>
</tr>
</tbody>
</table>
<pre class="r"><code>notas.dos.alunos &lt;- c(6.0,5.1,6.8,2.8,6.1,9.0,4.3,10.4,6.0,7.9,8.9,6.8,9.8,4.6,11.3,8.0,6.7,4.5)</code></pre>
<p>Quantos valores iguais ou maiores que cinco? <code>sum(notas.dos.alunos&gt;=5)</code></p>
<p>Quantos alunos tiraram abaixo de 5? E abaixo de 4?</p>
<p>Qual a proporção deste valores em relação ao total?</p>
<pre class="r"><code>sum(notas.dos.alunos &gt;= 5)/length(notas.dos.alunos)</code></pre>
<pre><code>## [1] 0.7777778</code></pre>
<p>Como saber a quantidade dos dados utilizando a função <code>sum()</code> com os operadores? <em>Não vale utilizar a função length.</em></p>
<pre class="r"><code>sum(notas.dos.alunos != 0)</code></pre>
<pre><code>## [1] 18</code></pre>
</div>
</div>
<div id="importando-dados-no-rstudio" class="section level1">
<h1>Importando dados no RStudio</h1>
<p>O formato <strong>UNIVERSAL</strong> de tabela de dados para análise estatística é o seguinte: cada <strong>LINHA</strong> é uma observação e cada <strong>COLUNA</strong> é uma variável ou atributo que foi tomado em cada observação. Existem diversas maneiras para importar os dados no programa R, Alguns dos formatos mais utilizados são:</p>
<ul>
<li>CSV (Comma separated values), HTML, XML, json, HDF5, Arquivos Xls (EXCEL), Dados em tabela, Dados espaçados por TAB, linhas de arquivos de texto, SPSS, Stata)…</li>
</ul>
<p>O modelo CSV é o mais utilizado para armazenar informações em tabelas, porque é feito diretamente no EXCEL. Nesse modelo o separador (vírgula, ponto e vírgula) indica a passagem para a próxima coluna e a tabela pode ter um cabeçalho (Header) com os nomes das colunas ou não. O arquivo de texto com extensão .txt, geralmente usa espaços. Isso acaba gerando problema de leitura no R, porque muitos usuários usam nomes de variáveis muito grandes, palavras compostas, de forma a desalinhar as colunas das variáveis. Daí, como a separação das variáveis é por meio de espaços, acaba gerando problema de leitura.</p>
<p>A função primária responsável pela importação de dados é a função <code>scan()</code>, as funções<code>read.table()</code>,<code>read.csv()</code> e <code>read.delim()</code>, usam a função<code>scan()</code>em seu algoritmo. A primeira ideia sobre importação de dados pode ser inserindo-os pelo teclado no próprio ambiente R. Para isso, usaremos a função scan(). Vejamos:</p>
<p><code>o &lt;- scan()</code></p>
<p>Após executado essa linha de comando, aparecerá no console 1: que significa, digitar o primeiro valor do objeto x, e depois clicar em ENTER. Depois 2:, que significa digitar o segundo valor, e clicar em ENTER. Depois de inserido todos os valores necessários, aperte a tecla ENTER duas vezes no console, para sair da função scan().</p>
<p>O modo mais simples de importar dados no RStudio é pelo botão <em>Import Dataset,</em> na aba <em>Environment</em>. Após esse comando podemos configurar a leitura do banco de dados, já que uma prévia de como os dados serão representados estará disponível no quadro Data Frame, se encontrarmos quaisquer problemas devemos resolvê-lo nas opções adicionais como utilizar outro separador, símbolos para casas decimais etc. Por fim é só digitar o nome do objeto e clicar no botão import.</p>
<p><code>dados_times &lt;- read.csv("tabela.csv", header = T)</code></p>
<p>Por definição essa função abre arquivos que foram salvos utilizando a vírgula como separador, read.csv2 (abre arquivos que foram delimitados por ; )</p>
<p>Para saber qual o separador foi utilizado basta somente abrir o arquivo com o Bloco de Notas.</p>
<p>Utilizamos a função com header = TRUE já que neste CSV, a primeira linha indica o nome das colunas, ou seja, é seu cabeçalho (seu header). Caso utilizássemos header = FALSE, os valores constantes na primeira linha não seriam os nomes das colunas.</p>
<p>O argumento dec=“.” quer dizer foi usado “.” na parte decimal dos dados originalmente digitados, sep = “\t” quer dizer que quando o arquivo foi salvo com a extensão .txt, optou-se pelo separador de colunascom tabulação.</p>
<p>Também podemos copiar e colar valores diretamente de arquivos, como .pdf ou .docx, através do comando read.delim.</p>
<p>Ctrl+V:</p>
<p><code>tabela &lt;- read.delim("clipboard", row.names=1)</code></p>
</div>
<div id="manipulação-gráfica" class="section level1">
<h1>Manipulação Gráfica</h1>
<p>O programa R possui uma interface gráfica que funciona através de comandos e argumentos: Tipos de gráficos: <code>barplot(); pie(); hist(); plot()</code>.</p>
<p>Rótulos: main = “nome”, xlab = “nome”, ylab = “nome”</p>
<p>Tamanho dos caracteres: ‘cex’ (character expansion)</p>
<p>Titulo: use ’cex.main=valor.</p>
<p>Para os eixos, use o argumento ‘cex.axis=valor’.</p>
<p>Para o nome dos eixos, use ‘cex.lab=valor’.</p>
<p>Cores: col=‘blue’</p>
<p>Símbolo do plot (circulo, quadrado,…) usa-se o ‘pch’.</p>
<p>Molduras do gráfico: bty=“L”- retira as molduras direita e superior; box()- adiciona moldura.</p>
<p>Limite das escalas dos eixos: ‘xlim’ e ‘ylim’.</p>
<p>Linhas, pontos: arrows() - adiciona seta; lines() - adiciona linha; points()- adiciona pontos.</p>
<p>Legenda: legend()</p>
<p>Para inserir um texto dentro do gráfico, utilize o comando “text”</p>
<p>text(posição eixo X, posição eixo Y, “texto a inserir”, outros argumentos)</p>
<p>Para inserir um texto fora da área do gráfico, utilize o comando “mtext”</p>
<p>mtext(“texto”, side = posição, line = posição, adj = posição entre esquerda(0) e direita (1)</p>
<p><strong>Para salvar gráficos no R em resolução máxima utilizamos o seguinte comando antes de plotar os gráficos:</strong></p>
<p><code>tiff("arquivo.tif", res = 300, type = "windows", width = 3000, height = 2000)</code></p>
<p><br />
plota o gráfico e encerra com</p>
<p><code>dev.off()</code></p>
<p>OU</p>
<p><code>png(filename="teste.png", height=8, width=16, unit="cm", res=300)</code></p>
<p>#Argumento mfrow (colunas,linhas), argumento mar faz referência aos tamanhos dos espaços no gráfico; <code>par(mfrow=c(1,2)</code>,<code>mar=c(1,1,1,1)</code>, <code>oma=c(1,1,0,0))</code></p>
<div id="ggplot2" class="section level2">
<h2>GGPLOT2</h2>
<p>É um pacote gráfico que faz parte da coleção de pacotes chamada tidyverse destinada para Análise de Dados. A Principal característica desse pacote é que ele descreve um gráfico a partir dos seus componentes, como se fossem camadas. <a href="https://github.com/rstudio/cheatsheets/blob/main/data-visualization-2.1.pdf">Ggplot Card</a><br />
</p>
<p><code>data("iris"); head(iris); str(iris); class(iris); colnames(iris); install.packages("ggplot2"); library(ggplot2)</code></p>
<p><code>ggplot(iris, aes(Petal.Length, Petal.Width, color = Species, shape = Species)) +</code></p>
<p><code>geom_point(fill = "black", size = 2, stroke = 1) +</code></p>
<p><code>scale_color_manual(values = c("purple", "yellow", "green"))  +</code></p>
<p><code>scale_shape_manual("Species", values = c(19, 21, 22))+</code></p>
<p><code>scale_x_continuous(name = "Comprimento da Pétala", breaks = 1:7) +</code></p>
<p><code>scale_y_continuous(name = "Largura da Pétala", breaks = 0:3, limits = c(0, 3)) +</code></p>
<p><code>labs(title = 'Relação entre o Comprimento e Largura da pétala de três spp da flor Iris')</code></p>
<p><img src="/rmarkdown-libs/grafico" /><br />
</p>
<div id="mapeamento-estético" class="section level3">
<h3>Mapeamento Estético</h3>
<p>Responsável pela personalização visual do gráfico</p>
<p>Função aes()</p>
<p>Posição (x e y);</p>
<p>Cor (color);</p>
<p>Tamanho (size);</p>
<p>Preenchimento (fill);</p>
<p>Transparência (alpha);</p>
<p>Texto (label).</p>
<p>Forma (shape)</p>
<p>Objeto Geométrico: Tipo de Gráficos</p>
<p>Função geom_ + Tipo do objeto</p>
<p>Dispersão (scatterplot): geom_point()</p>
<p>Gráfico de bolhas: geom_point()</p>
<p>Gráfico de barras: geom_bar() e geom_col()</p>
<p>Histograma: geom_histogram()</p>
<p>Boxplot: geom_boxplot()</p>
<p>Densidade: geom_density()</p>
<p>Gráfico de linhas: geom_line()</p>
<p><img src="/rmarkdown-libs/1.png" /></p>
</div>
</div>
</div>
<div id="funções" class="section level1">
<h1>Funções</h1>
<p>Aqui desenvolveremos e conheceremos mais a fundo o princípio da função do R, segundo o primeiro princípio (princípio do objeto) a função também é um objeto e elas são constituídas por três componentes: Argumentos (função <em><code>formals()</code></em>), Corpo (função <em><code>body()</code></em>) e o Ambiente (função <em><code>environment()</code></em>).</p>
<p>Podemos consultar os três componentes da função aov.</p>
<pre class="r"><code>formals(aov); body(aov); environment(aov)</code></pre>
<pre><code>## $formula
## 
## 
## $data
## NULL
## 
## $projections
## [1] FALSE
## 
## $qr
## [1] TRUE
## 
## $contrasts
## NULL
## 
## $...</code></pre>
<pre><code>## {
##     Terms &lt;- if (missing(data)) 
##         terms(formula, &quot;Error&quot;)
##     else terms(formula, &quot;Error&quot;, data = data)
##     indError &lt;- attr(Terms, &quot;specials&quot;)$Error
##     if (length(indError) &gt; 1L) 
##         stop(sprintf(ngettext(length(indError), &quot;there are %d Error terms: only 1 is allowed&quot;, 
##             &quot;there are %d Error terms: only 1 is allowed&quot;), length(indError)), 
##             domain = NA)
##     lmcall &lt;- Call &lt;- match.call()
##     lmcall[[1L]] &lt;- quote(stats::lm)
##     lmcall$singular.ok &lt;- TRUE
##     if (projections) 
##         qr &lt;- lmcall$qr &lt;- TRUE
##     lmcall$projections &lt;- NULL
##     if (is.null(indError)) {
##         fit &lt;- eval(lmcall, parent.frame())
##         fit$call &lt;- Call
##         structure(fit, class = c(if (inherits(fit, &quot;mlm&quot;)) &quot;maov&quot;, 
##             &quot;aov&quot;, oldClass(fit)), projections = if (projections) 
##             proj(fit))
##     }
##     else {
##         if (pmatch(&quot;weights&quot;, names(Call), 0L)) 
##             stop(&quot;weights are not supported in a multistratum aov() fit&quot;)
##         deparseb &lt;- function(expr) deparse1(expr, backtick = TRUE)
##         opcons &lt;- options(&quot;contrasts&quot;)
##         options(contrasts = c(&quot;contr.helmert&quot;, &quot;contr.poly&quot;))
##         on.exit(options(opcons))
##         allTerms &lt;- Terms
##         errorterm &lt;- attr(Terms, &quot;variables&quot;)[[1L + indError]]
##         intercept &lt;- attr(Terms, &quot;intercept&quot;)
##         ecall &lt;- lmcall
##         ecall$formula &lt;- as.formula(paste(deparseb(formula[[2L]]), 
##             &quot;~&quot;, deparseb(errorterm[[2L]]), if (!intercept) 
##                 &quot;- 1&quot;), env = environment(formula))
##         ecall$method &lt;- &quot;qr&quot;
##         ecall$qr &lt;- TRUE
##         ecall$contrasts &lt;- NULL
##         er.fit &lt;- eval(ecall, parent.frame())
##         options(opcons)
##         nmstrata &lt;- attr(terms(er.fit), &quot;term.labels&quot;)
##         nmstrata &lt;- sub(&quot;^`(.*)`$&quot;, &quot;\\1&quot;, nmstrata)
##         nmstrata &lt;- c(&quot;(Intercept)&quot;, nmstrata)
##         qr.e &lt;- er.fit$qr
##         rank.e &lt;- er.fit$rank
##         if (rank.e &lt; NROW(er.fit$coefficients)) 
##             warning(&quot;Error() model is singular&quot;)
##         qty &lt;- er.fit$residuals
##         maov &lt;- is.matrix(qty)
##         asgn.e &lt;- er.fit$assign[qr.e$pivot[1L:rank.e]]
##         maxasgn &lt;- length(nmstrata) - 1L
##         nobs &lt;- NROW(qty)
##         len &lt;- if (nobs &gt; rank.e) {
##             asgn.e[(rank.e + 1L):nobs] &lt;- maxasgn + 1L
##             nmstrata &lt;- c(nmstrata, &quot;Within&quot;)
##             maxasgn + 2L
##         }
##         else maxasgn + 1L
##         result &lt;- setNames(vector(&quot;list&quot;, len), nmstrata)
##         lmcall$formula &lt;- form &lt;- update(formula, paste(&quot;. ~ .-&quot;, 
##             deparseb(errorterm)))
##         Terms &lt;- terms(form)
##         lmcall$method &lt;- &quot;model.frame&quot;
##         mf &lt;- eval(lmcall, parent.frame())
##         xlev &lt;- .getXlevels(Terms, mf)
##         resp &lt;- model.response(mf)
##         qtx &lt;- model.matrix(Terms, mf, contrasts)
##         cons &lt;- attr(qtx, &quot;contrasts&quot;)
##         dnx &lt;- colnames(qtx)
##         asgn.t &lt;- attr(qtx, &quot;assign&quot;)
##         if (length(wts &lt;- model.weights(mf))) {
##             wts &lt;- sqrt(wts)
##             resp &lt;- resp * wts
##             qtx &lt;- qtx * wts
##         }
##         qty &lt;- as.matrix(qr.qty(qr.e, resp))
##         if ((nc &lt;- ncol(qty)) &gt; 1L) {
##             dny &lt;- colnames(resp) %||% paste0(&quot;Y&quot;, 1L:nc)
##             dimnames(qty) &lt;- list(seq(nrow(qty)), dny)
##         }
##         else dimnames(qty) &lt;- list(seq(nrow(qty)), NULL)
##         qtx &lt;- qr.qty(qr.e, qtx)
##         dimnames(qtx) &lt;- list(seq(nrow(qtx)), dnx)
##         for (i in seq_along(nmstrata)) {
##             select &lt;- asgn.e == (i - 1L)
##             ni &lt;- sum(select)
##             if (!ni) 
##                 next
##             xi &lt;- qtx[select, , drop = FALSE]
##             cols &lt;- colSums(xi^2) &gt; 1e-05
##             if (any(cols)) {
##                 xi &lt;- xi[, cols, drop = FALSE]
##                 attr(xi, &quot;assign&quot;) &lt;- asgn.t[cols]
##                 fiti &lt;- lm.fit(xi, qty[select, , drop = FALSE])
##                 fiti$terms &lt;- Terms
##             }
##             else {
##                 y &lt;- qty[select, , drop = FALSE]
##                 fiti &lt;- list(coefficients = numeric(), residuals = y, 
##                   fitted.values = 0 * y, weights = wts, rank = 0L, 
##                   df.residual = NROW(y))
##             }
##             if (projections) 
##                 fiti$projections &lt;- proj(fiti)
##             class(fiti) &lt;- c(if (maov) &quot;maov&quot;, &quot;aov&quot;, oldClass(er.fit))
##             result[[i]] &lt;- fiti
##         }
##         structure(class = c(&quot;aovlist&quot;, &quot;listof&quot;), result[!vapply(result, 
##             is.null, NA)], error.qr = if (qr) 
##             qr.e, call = Call, weights = if (length(wts)) 
##             wts, terms = allTerms, contrasts = cons, xlevels = xlev)
##     }
## }</code></pre>
<pre><code>## &lt;environment: namespace:stats&gt;</code></pre>
<p>O Corpo da função é onde está detalhadamente escrito a instrução necessária para que o programa execute determinada ação, podemos verificar o corpo de qualquer função no RStudio escrevendo apenas seu nome no console.</p>
<div id="chamadas-de-funções" class="section level2">
<h2>Chamadas de Funções:</h2>
<p>Podemos executar qualquer chamada de função de três maneiras, sendo elas: aninhada, intermediária e pelo operador pipe.</p>
<p>Primeiro iremos criar um conjunto com 50 números aleatórios provenientes de uma distribuição normal (para padronizarmos os dados, vamos enraizar o resultado executando a função <code>set.seed(5))</code> em seguida iremos calcular o desvio padrão para esses dados de três maneiras.<br />
</p>
<pre class="r"><code>set.seed(5); dados_normais &lt;- rnorm(50)</code></pre>
<ul>
<li>Função Aninhada:</li>
</ul>
<pre class="r"><code>sqrt(var(dados_normais))</code></pre>
<pre><code>## [1] 1.068682</code></pre>
<ul>
<li>Função Intermediária:</li>
</ul>
<pre class="r"><code>variancia &lt;- var(dados_normais)
desvio_padrao &lt;- sqrt(variancia); desvio_padrao</code></pre>
<pre><code>## [1] 1.068682</code></pre>
<ul>
<li>Operador Pipe: Podemos utilizar esse operador através do pacote <em><code>magrittr (%&gt;%)</code></em> ou pela função nativa <code>( |&gt; )</code> do R que foi implementada após a versão &gt;= 4.1 do R.</li>
</ul>
<pre class="r"><code>dados_normais |&gt;
  var()|&gt;
  sqrt()</code></pre>
<pre><code>## [1] 1.068682</code></pre>
<p>A função <strong>aninhada</strong> possui sua ordem de execução da <em>direita para a esquerda</em> e a principal vantagem dessa forma sintática é que não precisamos associar nomes aos objetos na hora da execução da função como fazemos na forma tradicional que é a <strong>intermediária</strong>. Por fim, a sintática do operador <strong>pipe</strong> é a mais complexa para assimilar, <em>o operador especial tem como primeiro operando o primeiro argumento da função no segundo operando</em>.</p>
</div>
</div>
<div id="estruturas-de-controle" class="section level1">
<h1>Estruturas de Controle</h1>
<p>As estruturas de controle são extremamente necessárias na hora da execução de uma ação através de qualquer linguagem de programação. Elas se referem a ordem com que as instruções fornecidas são executadas ou avaliadas em programas de computador. A ideia geral de funcionamento dessas funções é</p>
<p><br />
<code>função (condição {            expressão}</code><br />
</p>
<ul>
<li><code>if()</code>: Se quisermos executar um determinado código apenas se a condição for verdadeira e se a condição for falsa, queremos que nada seja feito, então:</li>
</ul>
<p>if (condição) {<br />
comandos a serem executados caso a condição nos parênteses seja verdadeira<br />
}<br />
</p>
<pre class="r"><code>i &lt;- 5
if (i &gt; 3){
  print(&quot;Maior que 3!&quot;)
}</code></pre>
<pre><code>## [1] &quot;Maior que 3!&quot;</code></pre>
<p>Caso desejamos uma resposta alternativa quando a condição for falsa utilizamos o <code>else()</code></p>
<p><code>if (condição) {    expressão sob condição = TRUE} else {    expressão sob condição = FALSE}</code></p>
<pre class="r"><code>if (is.numeric(i)) {
  print(&quot;Isso é um número&quot;)
} else {
  print(&quot;Isso não é um número&quot;)
}</code></pre>
<pre><code>## [1] &quot;Isso é um número&quot;</code></pre>
<pre class="r"><code>if (is.character(i)) {
  &quot;palavra&quot;
} else {
  if ((i %% 2) == 0) {
    &quot;número par&quot;
  } else {
    if ((i %% 2) == 1) {
      &quot;número ímpar&quot;
    }
  }
}</code></pre>
<pre><code>## [1] &quot;número ímpar&quot;</code></pre>
<ul>
<li><code>Ifelse()</code>Sintaxe: ifelse (Condição , comando executado caso a condição seja verdadeira , comando executado caso a condição seja falsa)</li>
</ul>
<pre class="r"><code>r &lt;- 4
g &lt;- 6
ifelse(r &gt; g, print(paste(&quot;O maior número é:&quot;, r)), print(paste(&quot;O maior número é:&quot;, g)))</code></pre>
<pre><code>## [1] &quot;O maior número é: 6&quot;</code></pre>
<pre><code>## [1] &quot;O maior número é: 6&quot;</code></pre>
<ul>
<li><p>As três estruturas de repetição no R são: repeat, while e for e são utilizadas para loop no programa.</p></li>
<li><p><code>for()</code></p></li>
</ul>
<p>Função que repete o código seguinte para o comprimento da sequência indicada entre parênteses.</p>
<p>Sintaxe: for (variável in sequência) {<br />
comandos a serem repetidos<br />
}</p>
<pre class="r"><code>for (i in 1:10) {
  print(i)
}</code></pre>
<pre><code>## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10</code></pre>
<ul>
<li><code>while()</code></li>
</ul>
<p>A tradução desta função nos ajuda a entendê-la mais: while significa enquanto. Então podemos ler essa função como: Enquanto alguma condição for verdadeira, o código abaixo será repetido.</p>
<p>Sintaxe: while (condição){<br />
comandos a serem repetidos<br />
}</p>
<pre class="r"><code>k &lt;- 1
while (k &lt;= 10) {
  print((k))
  k &lt;- k + 1
}</code></pre>
<pre><code>## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10</code></pre>
<p>Note que os dois últimos exemplos resultam na mesma coisa: o R vai retornar os números de 1 a 10 em sequência. Porém nós precisamos mudar o valor de a para que a sequência continue no caso do <code>while()</code> enquanto no <code>for()</code> a sequência progride sem precisarmos fazer isso manualmente. Além disso, ao usar <code>while()</code> precisamos declarar a variável antes para que o R possa testar a condição expressa dentro dos parênteses.</p>
<ul>
<li>repeat()</li>
</ul>
<p>Usando este comando, o R repetirá o código a seguir sem condições. Com isso, precisamos de mais uma função para mostrar ao programa quando deve parar de repetir o código. A função que faz isso é <code>break()</code>. Como sempre existe uma condição a ser satisfeita para o código continuar a ser repetido ou parar, então devemos também usar a função <code>if()</code>.</p>
<p>Sintaxe:</p>
<p>repeat {<br />
Comandos a serem repetidos<br />
if (Condição para que a repetição pare) break()<br />
}</p>
<pre class="r"><code>js &lt;- 1
repeat {
  print(js)
  js &lt;- js + 1
  if (js &gt; 10) break()
  }</code></pre>
<pre><code>## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10</code></pre>
<p>Neste exemplo obtivemos o mesmo resultado dos anteriores. Note que com o repeat, além de termos que ir aumentando o valor da variável manualmente, também precisamos especificar qual a condição para que o loop pare de ser realizado. Assim como quando usamos <code>while()</code>, aqui também precisamos declarar a variável antes.</p>
</div>
<div id="criando-funções" class="section level1">
<h1>Criando Funções</h1>
<p>Todas as funções utilizadas até agora no RStudio foram funções já desenvolvidas para o R provenientes de pacotes, algumas delas já são implementadas no programa como o pacote base e outras devem ser baixadas e anexadas ao programa para sua utilização, como é o caso de vários pacotes estatísticos disponíveis no CRAN.</p>
<p>Podemos desenvolver nossas próprias funções através do uso do <em><code>function()</code></em> na qual é um objeto que possui o modo <em>closure,</em> que possui sua sintaxe da seguinte forma:</p>
<p>funçãoX &lt;- function(args1, args2, …) {<br />
corpo: comandos..<br />
}</p>
<pre class="r"><code>funçãoX &lt;- function(x) {
  rest &lt;- x + 1
  return(rest)
}
funçãoX(x = 24)</code></pre>
<pre><code>## [1] 25</code></pre>
<p>Observamos que criamos uma função chamada <em>funçãoX</em>, cujo argumento de entrada é x. Observe que uma função é como um objeto do tipo vetor, associamos um nome ao objeto da mesma forma. O corpo apresenta uma delimitação por chaves {…}, em que apresenta um comando de atribuição res que se associa a soma x + 1, e por fim, o resultado dessa função, imprime res, por meio da função <code>return()</code>.</p>
<pre class="r"><code>formals(funçãoX)</code></pre>
<pre><code>## $x</code></pre>
<pre class="r"><code>body(funçãoX)</code></pre>
<pre><code>## {
##     rest &lt;- x + 1
##     return(rest)
## }</code></pre>
<pre class="r"><code>environment(funçãoX)</code></pre>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<div id="escopo-léxico" class="section level2">
<h2>Escopo Léxico</h2>
<p>Observamos que o terceiro componente de uma função do tipo closure é o seu Ambiente, no exemplo acima este ambiente é chamado de ambiente envolvente (ambiente global) esse ambiente representa o lugar onde a função desenvolvida se associou ao seu nome que no nosso caso é <em>funçãoX</em>, mas quando a <u>função é executada</u>, momentaneamente é criado um Ambiente de Execução na qual os nomes que estão no corpo da função serão associados aos objetos.</p>
<pre class="r"><code>bw &lt;- 25
fun &lt;- function() {
  bw &lt;- 2
  bw
}
fun()</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Por causa do ambiente de execução que o objeto x dentro da função é retornado, ao invés do que foi definido fora da função. Isso porque o ambiente de execução mascara os nomes definidos dentro da função dos nomes definidos fora da função. Esse é uma primeira característica do escopo léxico nas funções em R.</p>
<p>Anteriormente, falamos sobre a atribuição ( &lt;- ), que representa a forma como os nomes se associam aos objetos. Agora, o escopo vem a ser a forma como os nomes encontram seus valores associados. O termo léxico significa que as funções podem encontrar nomes e seus respectivos valores associados, definidos no ambiente onde a função foi definida, isto é, no ambiente de função. Claro que isso segue regras, e a primeira foi a máscara de nome falada anteriormente.</p>
<p>Porém quando não existe um nome vinculado a um objeto, e este foi definido no ambiente de função, o valor é repassado para o corpo da função.</p>
<pre class="r"><code>bw &lt;- 25
fun &lt;- function() {
  bw
}
fun()</code></pre>
<pre><code>## [1] 25</code></pre>
<p>Diferente do resultado acima, agora, o resultado da execução do comando foi 25, porque como a função procurou no ambiente de execuções e não encontrou esse nome, a função foi até o ambiente superior, no caso, o <u>ambiente global</u>. Todo ambiente tem um pai (ou ambiente superior). Essa hierarquização é observada no caminho de busca, que pode ser acessado por <code>search()</code>, ou seja,</p>
<pre class="r"><code>search()</code></pre>
<pre><code>## [1] &quot;.GlobalEnv&quot;        &quot;package:stats&quot;     &quot;package:graphics&quot; 
## [4] &quot;package:grDevices&quot; &quot;package:utils&quot;     &quot;package:datasets&quot; 
## [7] &quot;package:methods&quot;   &quot;Autoloads&quot;         &quot;package:base&quot;</code></pre>
<p>O ambiente corrente do R sempre será o ambiente ambiente global (.GlobalEnv). O ambiente de execução não aparece, porque ele é momentâneo.</p>
</div>
</div>
<div id="dicas-para-melhorar-a-sintaxe-no-r." class="section level1">
<h1>Dicas para melhorar a sintaxe no R.</h1>
<p>Para facilitar nossa compreensão sobre as linhas de comando desenvolvidas no R é aconselhável realizar essas configurações no RStudio que se referem ao diagnóstico do código escrito:</p>
<p><em>Tools &gt; Global options &gt; Code &gt; Editing. Marque todas as opções em General;</em></p>
<p><em>Tools &gt; Global options &gt; Code &gt; Display, Marque todas as opções;</em></p>
<p><em>Tools &gt; Global options &gt; Code &gt; Diagnostics. Marque todas as opções em R Diagnostics.</em></p>
<p>Com essas configurações as linhas de comando estarão estruturadas com cores que distinguem diversas estruturas como funções, espaçamentos etc.</p>
<div id="melhorando-o-script" class="section level2">
<h2>Melhorando o Script</h2>
<p>Existem alguns pacotes que automatizam a forma que organizamos nossas linhas de comando, o pacote <em><code>styler (função styler:::style_active_file())</code></em> e o <em><code>formatR</code></em> formatam nossas linhas de comando contidas em um diretório ou scrip para facilitar a compreensão sintática dos comandos. para mais exemplos acesse a <a href="https://yihui.org/formatr">página</a></p>
<p>Um dos erros mais comuns na sintaxe de um código é o seu espaçamento, no geral devemos colocar espaçamento entre a maioria dos operadores básicos do R, exceto pelos operadores :, :: e :::, e sempre é recomendado utilizar um espaço após a vírgula. Podemos exemplificar como seria a sintaxe ideal para determinado comando, vamos utilizar a seguinte linha de comando como exemplo:</p>
<pre class="r"><code>fun1 &lt;- &quot;desviopadrao&lt;-sqrt(var(dados_normais))&quot;</code></pre>
<p>Observamos que a forma sintática utilizada nesse comando está bastante confusa sem os devidos espaçamentos, para verificarmos a melhor forma que poderíamos escrever esse comando é só utilizar a função <em><code>style_text(fun1)</code></em>, do pacote <em><code>style</code>,</em> mas antes de executar essa função no RStudio precisaremos instalar 3 pacotes que são: <em><code>styler</code>, <code>prettycode</code> e <code>rstudioapi</code>,</em> para tanto, vamos utilizar a função <em>combine <code>c()</code>:</em></p>
<p><code>install.packages(c("prettycode", "styler", "rstudioapi"))</code></p>
<p>Em seguida iremos utilizar o comando <em>styler::style_text(fun1)</em></p>
<pre class="r"><code>styler::style_text(fun1)</code></pre>
<pre><code>## desviopadrao &lt;- sqrt(var(dados_normais))</code></pre>
<pre class="r"><code>comando &lt;- &quot;media&lt;-mean(x+1/length(x),na.rm=TRUE)&quot;</code></pre>
<pre class="r"><code>styler::style_text(comando)</code></pre>
<pre><code>## media &lt;- mean(x + 1 / length(x), na.rm = TRUE)</code></pre>
</div>
<div id="utilizando-chaves" class="section level2">
<h2>Utilizando chaves</h2>
<p>Quando usamos chaves em um comando, devemos evitar abri-lo e fechá-lo na mesma linha. E ainda, quando é função, as linhas de comando inseridas dentro das chaves, inserimos um recuo de dois espaços para entendermos a hierarquização das funções, isto é, função dentro de função.</p>
<p>No demais, devemos estar atentos em não nomear nossos objetos com os nomes existentes no programa, para verificar se determinado nome já está associado a algum objeto basta utilizar a função <em><code>exists()</code>,</em> por exemplo: <em>exists(“aov”)</em> se a função retornar com o TRUE, significa que tal nome já está associado a determinado objeto no programa, devemos utilizar nomes curtos e comentar cada linha de comando com o uso do # para facilitar o entendimento posteriormente a criação da rotina.</p>
</div>
</div>
<div id="o-que-é-um-pacote" class="section level1">
<h1>O que é um Pacote?</h1>
<p>Basicamente um pacote é um diretório de arquivos necessários para rodar determinado conjunto de códigos, funções, dados, documentação de ajuda etc. O programa R em sua forma mais básica possui 30 pacotes que são fundamentais para a utilização plena do programa. Existem mais ou menos 17.300 pacotes disponíveis no CRAN. O objetivo básico de um pacote é automatizar rotinas no R, digamos que para um pesquisador calcular o desvio padrão, intervalo de confiança e realizar uma anova nos seus dados ele precise escrever um série de rotinas no programa R, se esse mesmo pesquisador decidir aplicar a mesma metodologia para outro conjunto de dados ele teria que refazer todas as linhas de comando novamente ocasionando trabalhos desnecessários, por outro lado, com a criação de pacotes estatísticos o pesquisador já tem em mãos rotina já prontas esperando apenas algumas linhas de comando para rodar toda a análise.</p>
<p>A estrutura básica de um pacote é composta pelos seguintes “arquivos”:</p>
<ul>
<li><p>DESCRIPTION: que é basicamente um arquivo de texto contendo todas as informações descritivas sobre o pacote.</p></li>
<li><p>NAMESPACE: serve para destinar a importação e exportação de funções no pacote, ele dita quais funções serão exportadas na hora do carregamento do pacote pela função <em>library()</em> ou <em>require().</em></p></li>
<li><p>R/: é um subdiretório contendo todos os scrips com as funções em R, basicamente é o cérebro do pacote</p></li>
<li><p>Man/: esse subdiretório apresenta os arquivos de ajuda (.Rd).</p></li>
</ul>
</div>
<div id="instalando-e-carregando-pacotes" class="section level1">
<h1>Instalando e Carregando Pacotes</h1>
<p>A Função que instala pacotes no R é a <em><code>install.packages()</code>. E u</em>m dos pacotes mais utilizados no R é o vegan, ele foi criado por vários pesquisadores e tem o propósito de rodar várias análises no âmbito da ecologia, como Índices de Diversidade, Métodos de Ordenação, Análise da Diversidade e outras funções para ecólogos de comunidade.</p>
<p><code>Install.packages("vegan")</code></p>
<p>Podemos instalar vários pacotes simultaneamente utilizamos a função c() para criar um vetor: <em><code>install.packages(c("vegan","sos"))</code></em></p>
<p>Para carregar o pacote utilizamos a função <em>library(Nome do Pacote Desejado)</em></p>
<p>Podemos acessar os dados contidos nos pacotes através do argumento <code>data()</code></p>
</div>
<div id="usando-os-operadores-e" class="section level1">
<h1>Usando os Operadores :: e :::</h1>
<p>Para executarmos uma função de um determinado pacote sem a necessidade de carregar o pacote (library(pacote)) utilizamos o operador ::, contudo se conhecemos a estrutura de um pacote e sabemos que o pacote contém função não exportadas pelo namespace basta utilizar o comando ::: para carregar essas funções, mas não recomendamos a utilização de funções internas no desenvolvimento de pacotes uma vez que tais funções podem passar por mudanças se os desenvolvedores atualizarem algum índice etc.</p>
</div>
